<center><h1>数据结构学习笔记</h1></center>

### 1. 稀疏矩阵的表示方法以及快速转置算法  
- 表示方法：  
使用三元素<x,y,z>表示。其中x表示行号，y表示列号，z表示matrix[i][j]的值  
- 求快速转置算法  
实现考虑每一列的三元组应该被放置的起始位置，然后依次填到相应区域去。相应需要的辅助数组num[i]表示三元组中第i列的元素有多少个。cpot[i]表示第i列的元素应该被放置的起始位置。  
[详细解释](https://www.cnblogs.com/lyxcode/p/8321725.html)  

### 2. 删除数组元素  
**核心思路**：维护下标index指向删除后数组的最后一个元素  
以删除数组中所有值为x的元素为例
```
int work(vector<int>&nums,int x)
{
	int index = -1;//index指向有效数组的最后一位
	for (int i = 0; i < nums.size(); ++i)
	{
		if (nums[i] != x)
		{
			swap(nums[i], nums[++index]);
		}
	}
	return index;
}
```
再以删除有序数组中所有重复元素为例
```
int work(vector<int>&nums)
{
	const int inf = 0x3f3f3f3f;
	int index = -1;//index指向有效数组的最后一位
	int pre = inf;
	for (int i = 0; i < nums.size(); ++i)
	{
		if (nums[i] != pre)
		{
			pre = nums[i];
			swap(nums[i], nums[++index]);
		}
	}
	return index;
}
```
### 3.交换数组中的两部分  
数组A[m+n]中由两部分[a[0]-a[m-1]]和[b[m]-b[n-1]]组成  
**思路**：先把数组整个逆置，然后分别逆置这两个部分  
**可以联系的题目**：[反转单词顺序](https://www.acwing.com/problem/content/73/)
### 4.寻找数组中出现次数超过一半的数字  
**经典问题**  
直接上代码  
```
int moreThanHalfNum_Solution(vector<int>& nums) {
        int cnt=0;
        int val=0x3f3f3f3f;
        for(auto x:nums)
        {
            if(x==val) cnt++;
            else cnt--;
            if(cnt<=0) {cnt=1;val=x;}
        }
        return val;
    }
```
