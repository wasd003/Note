<center><h1>数据结构学习笔记</h1></center>

### 1. 稀疏矩阵的表示方法以及快速转置算法  
- 表示方法：  
使用三元素<x,y,z>表示。其中x表示行号，y表示列号，z表示matrix[i][j]的值  
- 求快速转置算法  
实现考虑每一列的三元组应该被放置的起始位置，然后依次填到相应区域去。相应需要的辅助数组num[i]表示三元组中第i列的元素有多少个。cpot[i]表示第i列的元素应该被放置的起始位置。  
[详细解释](https://www.cnblogs.com/lyxcode/p/8321725.html)  

### 2. 删除数组元素  
**核心思路**：维护下标index指向删除后数组的最后一个元素  
以删除数组中所有值为x的元素为例
```
int work(vector<int>&nums,int x)
{
	int index = -1;//index指向有效数组的最后一位
	for (int i = 0; i < nums.size(); ++i)
	{
		if (nums[i] != x)
		{
			swap(nums[i], nums[++index]);
		}
	}
	return index;
}
```
再以删除有序数组中所有重复元素为例
```
int work(vector<int>&nums)
{
	const int inf = 0x3f3f3f3f;
	int index = -1;//index指向有效数组的最后一位
	int pre = inf;
	for (int i = 0; i < nums.size(); ++i)
	{
		if (nums[i] != pre)
		{
			pre = nums[i];
			swap(nums[i], nums[++index]);
		}
	}
	return index;
}
```
### 3.交换数组中的两部分  
数组A[m+n]中由两部分[a[0]-a[m-1]]和[b[m]-b[n-1]]组成  
**思路**：先把数组整个逆置，然后分别逆置这两个部分  
**可以联系的题目**：[反转单词顺序](https://www.acwing.com/problem/content/73/)
### 4.寻找数组中出现次数超过一半的数字  
**经典问题**  
直接上代码  
```
int moreThanHalfNum_Solution(vector<int>& nums) {
        int cnt=0;
        int val=0x3f3f3f3f;
        for(auto x:nums)
        {
            if(x==val) cnt++;
            else cnt--;
            if(cnt<=0) {cnt=1;val=x;}
        }
        return val;
    }
```
### 5.卡特兰数的推导  
[推导](https://www.cnblogs.com/zyt1253679098/p/9190217.html)  

### 6.手写堆  
- 完全二叉树：按照先左儿子，再右儿子，逐层添加的顺序添加节点形成的二叉树叫做完全二叉树。  
完全二叉树的存储：使用数组存储，从0开始存，对于当前结点index,2×index+1为其左儿子，2×index+2为其右儿子，(index-1)/2为其父亲。  
- 最小堆：一颗完全二叉树，保证父亲节点比左右儿子小。  
- 堆的常用操作：  
1. Heapify(int index)  //将以index为根节点的完全二叉树变为堆，前提是该二叉树与堆相比只有index结点是错误的。  
2. Push(int x) 
3. Pop  
4. Top  
```
#include<iostream>
using namespace std;
template<class Type>
class Heap
{
private:
	int heapSize;
	static const int maxn = 1000;
	Type nums[maxn];
public:
	void Heapify(int index);//将以index为根节点的完全二叉树变为最小堆(只能处理index结点发生变化的情况)
	void Push(const Type& x);
	void Pop();
	Type Top();
	Heap() :heapSize(0) {}
};
template<class Type>
void Heap<Type>::Heapify(int index)
{
	int left = index * 2 + 1;
	while (left < heapSize)
	{
		Type minNum = nums[left];
		int minIndex = left;
		if (left + 1 < heapSize&&nums[left + 1] < minNum)
		{
			minNum = nums[left + 1];
			minIndex++;
		}
		if (minNum < nums[index])
		{
			swap(nums[index], nums[minIndex]);
			index = minIndex;
			left = index * 2 + 1;
		}
		else break;
	}
}
template<class Type>
void Heap<Type>::Push(const Type& x)
{
	nums[heapSize++] = x;
	int index = heapSize - 1;
	while (index > 0)
	{
		int fa = (index - 1) / 2;
		if (nums[index] < nums[fa])
		{
			swap(nums[index], nums[fa]);
			index = fa;
		}
		else break;
	}
}

template<class Type>
Type Heap<Type>::Top()
{
	return nums[0];
}

template<class Type>
void Heap<Type>::Pop()
{
	swap(nums[0], nums[heapSize - 1]);
	heapSize--;
	Heapify(0);
}
```
### 7.希尔排序  
希尔排序是升级的直接插入排序，利用直接插入排序对于数据量小，部分有序的情况效率较高的特点。先对数据进行分组，分组后对每一组分别进行直接插入排序，然后将组间距/2，继续，直至组间距为1。  
code:
```
for (int gap = N / 2; gap >= 1; gap /= 2)//组间距
	{
		for (int start = gap; start < gap + gap; ++start)//从每一组的第二个元素开始直接插入排序，因为只有一个元素的情况视为有序
		{
			for (int i = start; i < N; i += gap)//对每一组依次进行直接插入排序
			{
				if (nums[i] < nums[i - gap])
				{
					int rem = nums[i]; int j;
					for (j = i - gap; j >= 0; j -= gap)
					{
						nums[j + gap] = nums[j];
						cnt++;
						if (nums[j] <= rem)
						{
							nums[j + gap] = rem;
							break;//别忘了插入后及时break
						}
					}
					if (j < 0)
					{
						nums[j + gap] = rem;
						cnt++;
					}
				}
			}
		}
	}
```
### 8.基数排序  
只适用于非负整数的情况。  
找到所有数组中所有数字的最大位数k，循环k次。  
对于每次循环，根据第i(i从个位递增一直到第k-1位)是几划分到0-9这十个桶中去。然后按照通过的顺序输出到nums中。  
code:
```
const int N=nums.size();
        int maxv = INT_MIN;
        for (int i = 0; i < N; ++i)
        {
            int num = nums[i];
            int s = 0;
            while (num)
            {
                num /= 10;
                s++;
            }
            maxv = max(maxv, s);
        }
        int base[10][5000];
        int index[10];
        memset(index, 0, sizeof index);
        int s = 1;
        while (maxv--)
        {
            for (int i = 0; i < N; ++i)
            {
                int id = (nums[i] / s) % 10;
                base[id][index[id]++] = nums[i];
            }
            s *= 10;
            int k = 0;
            for (int i = 0; i < 10; ++i)
            {
                for (int j = 0; j < index[i]; ++j)
                {
                    nums[k++] = base[i][j];
                }
            }
            memset(index, 0, sizeof index);
        }
```  
### 9.堆排序  
#### 堆化  
从最后一个结点的父节点开始，倒序heapify就可以将任意的完全二叉树转化为堆。  
#### 堆排  
将一个无序数组堆化(最大堆)之后每次将堆顶元素与最后一个元素交换，heapSize--，heapify，直至heapsize为1(实际上就是不停pop，pop出的元素放置在倒序放在数组末尾)  
code
```
void heapify(vector<int>&nums,int index,int heapSize)
    {
        int left = index * 2 + 1;
        while (left < heapSize)
        {
            int maxIndex = left;
            int maxNum = nums[left];
            if (left + 1 < heapSize&&nums[left + 1] >maxNum)
            {
                maxIndex++;
                maxNum = nums[maxIndex];
            }
            if (maxNum > nums[index])
            {
                swap(nums[index], nums[maxIndex]);
                index = maxIndex;
            }
            else break;
            left = index * 2 + 1;
        }
    }
    vector<int> sortArray(vector<int>& nums) {
        const int N=nums.size();
        int parent = (N - 1) / 2;
        for (int i = parent; ~i; --i)
        {
            heapify(nums, i,N);//堆化
        }
        int heapSize = N;
        while(heapSize>=1)
        {
            swap(nums[0], nums[heapSize - 1]);
            heapSize--;
            heapify(nums, 0, heapSize);
        }
        return nums;
    }
```

### 10.对dijkstra算法的理解  
1. S集合是所有确定最短路径的点，T集合是所有还未确定最短路径的点。  
2. D[i]：对于S集合中的表示从源点到i的最短路径，对于T集合中的点，表示仅从S集合中的点中转到达i的最短路径。  
3. 关键：从T集合升级到S集合的方法：**当前所有T集合中的点，谁的D最小，谁可以升级到S集合**。因为从其他T集合中的点中转一定不如现在已经计算出的情况。